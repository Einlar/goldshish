
scalar JSON
scalar Date

# see https://docs.hasura.io/1.0/graphql/manual/queries/query-filters.html

input String_Selector {
  _eq: String
  #_gt: String
  #_gte: String
  #_ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  #_lt: String
  #_lte: String
  #_neq: String
  #_nilike: String
  #_nin: [String!]
  #_nlike: String
  #_nsimilar: String
  #_similar: String
}

input String_Array_Selector {
  _in: [String!]
  _contains: String
  # _contains_all: [String_Selector]
}

input Int_Selector {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  #_is_null: Boolean
  _lt: Int
  _lte: Int
  #_neq: Int
  #_nin: [Int!]
}

input Int_Array_Selector {
  contains: Int_Selector
  # contains_all: [Int_Selector]
}

input Float_Selector {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  #_is_null: Boolean
  _lt: Float
  _lte: Float
  #_neq: Float
  #_nin: [Float!]
}

input Float_Array_Selector {
  contains: Float_Selector
  # contains_all: [Float_Selector]
}

input Boolean_Selector {
  _eq: Boolean
  #_neq: Boolean
}

input Boolean_Array_Selector {
  contains: Boolean_Selector
  # contains_all: [Boolean_Selector]
}

input Date_Selector {
  _eq: Date
  _gt: Date
  _gte: Date
  _in: [Date!]
  #_is_null: Boolean
  _lt: Date
  _lte: Date
  #_neq: Date
  #_nin: [Date!]
}

input Date_Array_Selector {
  contains: Date_Selector
  # contains_all: [Date_Selector]
}

# column ordering options
enum SortOptions {
  asc
  desc
}

input OptionsInput {
  # Whether to enable caching for this query
  enableCache: Boolean
  # For single document queries, return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

type Site {
  title: String
  url: String
  logoUrl: String
  sourceVersion: String
}
type IntlValue {
  locale: String
  value: String
}
input IntlValueInput{
  locale: String
  value: String
}
directive @intl on FIELD_DEFINITION

  input AuthPasswordInput {
    email: String
    password: String
  }
  type AuthResult {
    token: String
    userId: String
  }
  type LogoutResult {
    userId: String
  }

  input SignupInput {
    email: String
    password: String
  }
  type SignupResult {
    userId: String
  }

  input SetPasswordInput {
    newPassword: String
  }

  #type SetPasswordResult # Will auth user again so we reuse AuthResult atm

  input ResetPasswordInput {
    token: String
    newPassword: String
  }
  type ResetPasswordResult {
    userId: String
  }

  input VerifyEmailInput {
    token: String
  }
  type VerifyEmailResult {
    userId: String
  }

  input AuthEmailInput {
    email: String
  }


  type FSFile {
    _id: String
    name: String!
    extension: String
    extensionWithDot: String
    url(version: String = "original"): String
    meta: JSON
    type: String
    mime: String
    size: Int
    userId: String
    user: User
    isVideo: Boolean
    isAudio: Boolean
    isImage: Boolean
    isText: Boolean
    isJSON: Boolean
    isPDF: Boolean
  }


  # A file upload.
  scalar File


# A user object
type User {
  _id: String 
  username: String 
  emails: [JSON] 
  createdAt: Date 
  isAdmin: Boolean 
  locale: String 
  profile: JSON 
  services: JSON 
  displayName: String 
  email: String 
  emailHash: String 
  avatarUrl: String 
  slug: String 
  groups: [String] 
  pageUrl: String 
  pagePath: String 
  editUrl: String 
  createdAtFormatted(format: String = "YYYY/MM/DD"): String 
}


input DeleteUserInput{
  filter: UserFilterInput
  id: String
}

input SingleUserInput {
  # filtering
  filter: UserFilterInput
  sort: UserSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: UserSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiUserInput {

  # filtering
  filter: UserFilterInput
  sort: UserSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleUserOutput{
  result: User
}

type  MultiUserOutput{
  results: [User]
  totalCount: Int
}

type UserMutationOutput{
  data: User
}

input CreateUserInput {
  data: CreateUserDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateUserDataInput {
  username: String 
  isAdmin: Boolean 
  locale: String 
  profile: JSON 
  displayName: String 
  email: String 
  groups: [String] 
}

input UpdateUserInput{
  filter: UserFilterInput
  id: String
  data: UpdateUserDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertUserInput{
  filter: UserFilterInput
  id: String
  data: UpdateUserDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateUserDataInput {
  username: String 
  isAdmin: Boolean 
  locale: String 
  displayName: String 
  email: String 
  groups: [String] 
}

input UserFilterInput {
  _and: [UserFilterInput]
  _not: UserFilterInput
  _or: [UserFilterInput]


  _id: String_Selector
  username: String_Selector

  createdAt: Date_Selector
  isAdmin: Boolean_Selector
  locale: String_Selector

  displayName: String_Selector
  email: String_Selector
  emailHash: String_Selector
  avatarUrl: String_Selector
  slug: String_Selector
  groups: String_Array_Selector
  pageUrl: String_Selector
  pagePath: String_Selector
  editUrl: String_Selector
}

input UserSortInput {
  _id: SortOptions
  username: SortOptions
  emails: SortOptions
  createdAt: SortOptions
  isAdmin: SortOptions
  locale: SortOptions
  services: SortOptions
  displayName: SortOptions
  email: SortOptions
  emailHash: SortOptions
  avatarUrl: SortOptions
  slug: SortOptions
  groups: SortOptions
  pageUrl: SortOptions
  pagePath: SortOptions
  editUrl: SortOptions
}

input UserSelectorInput {
  _and: [UserSelectorInput]
  _or: [UserSelectorInput]

}

input UserSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}


# Type for Courses
type Course {
  _id: String 
  courseName: String 
  slug: String 
  description: String 
  folders: [Folder] 
  notes: [Note] 
}


input DeleteCourseInput{
  filter: CourseFilterInput
  id: String
}

input SingleCourseInput {
  # filtering
  filter: CourseFilterInput
  sort: CourseSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: CourseSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiCourseInput {

  # filtering
  filter: CourseFilterInput
  sort: CourseSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleCourseOutput{
  result: Course
}

type  MultiCourseOutput{
  results: [Course]
  totalCount: Int
}

type CourseMutationOutput{
  data: Course
}

input CreateCourseInput {
  data: CreateCourseDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateCourseDataInput {
  courseName: String 
  description: String 
}

input UpdateCourseInput{
  filter: CourseFilterInput
  id: String
  data: UpdateCourseDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertCourseInput{
  filter: CourseFilterInput
  id: String
  data: UpdateCourseDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateCourseDataInput {
  courseName: String 
  description: String 
}

input CourseFilterInput {
  _and: [CourseFilterInput]
  _not: CourseFilterInput
  _or: [CourseFilterInput]


  _id: String_Selector
  courseName: String_Selector
  slug: String_Selector
  description: String_Selector
}

input CourseSortInput {
  _id: SortOptions
  courseName: SortOptions
  slug: SortOptions
  description: SortOptions
}

input CourseSelectorInput {
  _and: [CourseSelectorInput]
  _or: [CourseSelectorInput]

}

input CourseSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}


# Type for Professors
type Professor {
  _id: String 
  professorName: String 
  courseId: String 
  course: Course 
}


input DeleteProfessorInput{
  filter: ProfessorFilterInput
  id: String
}

input SingleProfessorInput {
  # filtering
  filter: ProfessorFilterInput
  sort: ProfessorSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: ProfessorSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiProfessorInput {

  # filtering
  filter: ProfessorFilterInput
  sort: ProfessorSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleProfessorOutput{
  result: Professor
}

type  MultiProfessorOutput{
  results: [Professor]
  totalCount: Int
}

type ProfessorMutationOutput{
  data: Professor
}

input CreateProfessorInput {
  data: CreateProfessorDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateProfessorDataInput {
  professorName: String 
  courseId: String 
}

input UpdateProfessorInput{
  filter: ProfessorFilterInput
  id: String
  data: UpdateProfessorDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertProfessorInput{
  filter: ProfessorFilterInput
  id: String
  data: UpdateProfessorDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateProfessorDataInput {
  professorName: String 
  courseId: String 
}

input ProfessorFilterInput {
  _and: [ProfessorFilterInput]
  _not: ProfessorFilterInput
  _or: [ProfessorFilterInput]


  _id: String_Selector
  professorName: String_Selector
  courseId: String_Selector
}

input ProfessorSortInput {
  _id: SortOptions
  professorName: SortOptions
  courseId: SortOptions
}

input ProfessorSelectorInput {
  _and: [ProfessorSelectorInput]
  _or: [ProfessorSelectorInput]

}

input ProfessorSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}


# Type for Folders
type Folder {
  _id: String 
  folderName: String 
  slug: String 
  description: String 
  courseId: String 
  course: Course 
  starred: Boolean 
}


input DeleteFolderInput{
  filter: FolderFilterInput
  id: String
}

input SingleFolderInput {
  # filtering
  filter: FolderFilterInput
  sort: FolderSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: FolderSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiFolderInput {

  # filtering
  filter: FolderFilterInput
  sort: FolderSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleFolderOutput{
  result: Folder
}

type  MultiFolderOutput{
  results: [Folder]
  totalCount: Int
}

type FolderMutationOutput{
  data: Folder
}

input CreateFolderInput {
  data: CreateFolderDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateFolderDataInput {
  folderName: String 
  description: String 
  courseId: String 
  starred: Boolean 
}

input UpdateFolderInput{
  filter: FolderFilterInput
  id: String
  data: UpdateFolderDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertFolderInput{
  filter: FolderFilterInput
  id: String
  data: UpdateFolderDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateFolderDataInput {
  folderName: String 
  description: String 
  courseId: String 
  starred: Boolean 
}

input FolderFilterInput {
  _and: [FolderFilterInput]
  _not: FolderFilterInput
  _or: [FolderFilterInput]


  _id: String_Selector
  folderName: String_Selector
  slug: String_Selector
  description: String_Selector
  courseId: String_Selector
  starred: Boolean_Selector
}

input FolderSortInput {
  _id: SortOptions
  folderName: SortOptions
  slug: SortOptions
  description: SortOptions
  courseId: SortOptions
  starred: SortOptions
}

input FolderSelectorInput {
  _and: [FolderSelectorInput]
  _or: [FolderSelectorInput]

}

input FolderSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}


# Type for Notes
type Note {
  _id: String 
  noteName: String 
  slug: String 
  description: String 
  courseId: String 
  course: Course 
  folderId: String 
  folder: Folder 
  professorId: String 
  professor: Professor 
  latest_verId: String 
  latest_ver: NoteItem 
  starred: Boolean 
  years: Float 
  date: Date 
  files: [NoteItem] 
  dateFormatted(format: String = "YYYY/MM/DD"): String 
}


input DeleteNoteInput{
  filter: NoteFilterInput
  id: String
}

input SingleNoteInput {
  # filtering
  filter: NoteFilterInput
  sort: NoteSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: NoteSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiNoteInput {

  # filtering
  filter: NoteFilterInput
  sort: NoteSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleNoteOutput{
  result: Note
}

type  MultiNoteOutput{
  results: [Note]
  totalCount: Int
}

type NoteMutationOutput{
  data: Note
}

input CreateNoteInput {
  data: CreateNoteDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateNoteDataInput {
  noteName: String 
  description: String 
  courseId: String 
  folderId: String 
  professorId: String 
  latest_verId: String 
  starred: Boolean 
  years: Float 
  date: Date 
}

input UpdateNoteInput{
  filter: NoteFilterInput
  id: String
  data: UpdateNoteDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertNoteInput{
  filter: NoteFilterInput
  id: String
  data: UpdateNoteDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateNoteDataInput {
  noteName: String 
  description: String 
  courseId: String 
  folderId: String 
  professorId: String 
  latest_verId: String 
  starred: Boolean 
  years: Float 
  date: Date 
}

input NoteFilterInput {
  _and: [NoteFilterInput]
  _not: NoteFilterInput
  _or: [NoteFilterInput]
  _byFolder: NoteByFolderFilterInput

  _id: String_Selector
  noteName: String_Selector
  slug: String_Selector
  description: String_Selector
  courseId: String_Selector
  folderId: String_Selector
  professorId: String_Selector
  latest_verId: String_Selector
  starred: Boolean_Selector
  years: Float_Selector
  date: Date_Selector
}

input NoteByFolderFilterInput{
  slug: String
}

input NoteSortInput {
  _id: SortOptions
  noteName: SortOptions
  slug: SortOptions
  description: SortOptions
  courseId: SortOptions
  folderId: SortOptions
  professorId: SortOptions
  latest_verId: SortOptions
  starred: SortOptions
  years: SortOptions
  date: SortOptions
}

input NoteSelectorInput {
  _and: [NoteSelectorInput]
  _or: [NoteSelectorInput]

}

input NoteSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}


# Type for NoteItems
type NoteItem {
  _id: String 
  createdAt: Date 
  userId: String 
  user: User 
  version: Float 
  description: String 
  parentNote: String 
  noteName: Note 
  noteId: JSON 
  noteUrl: FSFile 
  createdAtFormatted(format: String = "YYYY/MM/DD"): String 
}


input DeleteNoteItemInput{
  filter: NoteItemFilterInput
  id: String
}

input SingleNoteItemInput {
  # filtering
  filter: NoteItemFilterInput
  sort: NoteItemSortInput
  search: String
  id: String

  # backwards-compatibility
  "Deprecated (use 'filter/id' fields instead)."
  selector: NoteItemSelectorUniqueInput

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
  # An identifier to name the query's execution context
  contextName: String
}

input MultiNoteItemInput {

  # filtering
  filter: NoteItemFilterInput
  sort: NoteItemSortInput
  search: String
  offset: Int
  limit: Int

  # backwards-compatibility
  # A JSON object that contains the query terms used to fetch data
  "Deprecated (use 'filter/id' fields instead)."
  terms: JSON

  # options (backwards-compatibility)
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # An identifier to name the query's execution context
  contextName: String
  
}

type SingleNoteItemOutput{
  result: NoteItem
}

type  MultiNoteItemOutput{
  results: [NoteItem]
  totalCount: Int
}

type NoteItemMutationOutput{
  data: NoteItem
}

input CreateNoteItemInput {
  data: CreateNoteItemDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input CreateNoteItemDataInput {
  version: Float 
  description: String 
  parentNote: String 
  noteId: JSON 
}

input UpdateNoteItemInput{
  filter: NoteItemFilterInput
  id: String
  data: UpdateNoteItemDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpsertNoteItemInput{
  filter: NoteItemFilterInput
  id: String
  data: UpdateNoteItemDataInput!
  # An identifier to name the mutation's execution context
  contextName: String
}

input UpdateNoteItemDataInput {
  version: Float 
  description: String 
  parentNote: String 
  noteId: JSON 
}

input NoteItemFilterInput {
  _and: [NoteItemFilterInput]
  _not: NoteItemFilterInput
  _or: [NoteItemFilterInput]


  _id: String_Selector
  createdAt: Date_Selector
  userId: String_Selector
  version: Float_Selector
  description: String_Selector
  parentNote: String_Selector

}

input NoteItemSortInput {
  _id: SortOptions
  createdAt: SortOptions
  userId: SortOptions
  version: SortOptions
  description: SortOptions
  parentNote: SortOptions
  noteId: SortOptions
}

input NoteItemSelectorInput {
  _and: [NoteItemSelectorInput]
  _or: [NoteItemSelectorInput]

}

input NoteItemSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}




type Query {
  siteData: Site
  
  currentUser: User
  
  # A single User document fetched by ID or slug
  user(input: SingleUserInput!): SingleUserOutput
  
  # A list of User documents matching a set of query terms
  users(input: MultiUserInput):  MultiUserOutput
  
  # A single Course document fetched by ID or slug
  course(input: SingleCourseInput!): SingleCourseOutput
  
  # A list of Course documents matching a set of query terms
  courses(input: MultiCourseInput):  MultiCourseOutput
  
  # A single Professor document fetched by ID or slug
  professor(input: SingleProfessorInput!): SingleProfessorOutput
  
  # A list of Professor documents matching a set of query terms
  professors(input: MultiProfessorInput):  MultiProfessorOutput
  
  # A single Folder document fetched by ID or slug
  folder(input: SingleFolderInput!): SingleFolderOutput
  
  # A list of Folder documents matching a set of query terms
  folders(input: MultiFolderInput):  MultiFolderOutput
  
  # A single Note document fetched by ID or slug
  note(input: SingleNoteInput!): SingleNoteOutput
  
  # A list of Note documents matching a set of query terms
  notes(input: MultiNoteInput):  MultiNoteOutput
  
  # A single NoteItem document fetched by ID or slug
  noteItem(input: SingleNoteItemInput!): SingleNoteItemOutput
  
  # A list of NoteItem documents matching a set of query terms
  noteItems(input: MultiNoteItemInput):  MultiNoteItemOutput
  
}
  

type Mutation {
  authenticateWithPassword(input: AuthPasswordInput): AuthResult

  logout: LogoutResult

  signup(input: SignupInput): SignupResult

  setPassword(input: SetPasswordInput): AuthResult

  sendResetPasswordEmail(input: AuthEmailInput): Boolean

  resetPassword(input: ResetPasswordInput): ResetPasswordResult

  sendVerificationEmail(input: AuthEmailInput): Boolean

  verifyEmail(input: VerifyEmailInput): VerifyEmailResult

  # Mutation for creating new User documents
  createUser(
  input: CreateUserInput,
  "Deprecated (use 'input' field instead)."
  data: CreateUserDataInput
) : UserMutationOutput

  # Mutation for updating a User document
  updateUser(
  input: UpdateUserInput,
  "Deprecated (use 'input' field instead)."
  selector: UserSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateUserDataInput 
) : UserMutationOutput

  # Mutation for upserting a User document
  upsertUser(
  input: UpsertUserInput,
  "Deprecated (use 'input' field instead)."
  selector: UserSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateUserDataInput
) : UserMutationOutput

  # Mutation for deleting a User document
  deleteUser(
  input: DeleteUserInput,
  "Deprecated (use 'input' field instead)."
  selector: UserSelectorUniqueInput
) : UserMutationOutput

  # Mutation for creating new Course documents
  createCourse(
  input: CreateCourseInput,
  "Deprecated (use 'input' field instead)."
  data: CreateCourseDataInput
) : CourseMutationOutput

  # Mutation for updating a Course document
  updateCourse(
  input: UpdateCourseInput,
  "Deprecated (use 'input' field instead)."
  selector: CourseSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateCourseDataInput 
) : CourseMutationOutput

  # Mutation for upserting a Course document
  upsertCourse(
  input: UpsertCourseInput,
  "Deprecated (use 'input' field instead)."
  selector: CourseSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateCourseDataInput
) : CourseMutationOutput

  # Mutation for deleting a Course document
  deleteCourse(
  input: DeleteCourseInput,
  "Deprecated (use 'input' field instead)."
  selector: CourseSelectorUniqueInput
) : CourseMutationOutput

  # Mutation for creating new Professor documents
  createProfessor(
  input: CreateProfessorInput,
  "Deprecated (use 'input' field instead)."
  data: CreateProfessorDataInput
) : ProfessorMutationOutput

  # Mutation for updating a Professor document
  updateProfessor(
  input: UpdateProfessorInput,
  "Deprecated (use 'input' field instead)."
  selector: ProfessorSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateProfessorDataInput 
) : ProfessorMutationOutput

  # Mutation for upserting a Professor document
  upsertProfessor(
  input: UpsertProfessorInput,
  "Deprecated (use 'input' field instead)."
  selector: ProfessorSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateProfessorDataInput
) : ProfessorMutationOutput

  # Mutation for deleting a Professor document
  deleteProfessor(
  input: DeleteProfessorInput,
  "Deprecated (use 'input' field instead)."
  selector: ProfessorSelectorUniqueInput
) : ProfessorMutationOutput

  # Mutation for creating new Folder documents
  createFolder(
  input: CreateFolderInput,
  "Deprecated (use 'input' field instead)."
  data: CreateFolderDataInput
) : FolderMutationOutput

  # Mutation for updating a Folder document
  updateFolder(
  input: UpdateFolderInput,
  "Deprecated (use 'input' field instead)."
  selector: FolderSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateFolderDataInput 
) : FolderMutationOutput

  # Mutation for upserting a Folder document
  upsertFolder(
  input: UpsertFolderInput,
  "Deprecated (use 'input' field instead)."
  selector: FolderSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateFolderDataInput
) : FolderMutationOutput

  # Mutation for deleting a Folder document
  deleteFolder(
  input: DeleteFolderInput,
  "Deprecated (use 'input' field instead)."
  selector: FolderSelectorUniqueInput
) : FolderMutationOutput

  # Mutation for creating new Note documents
  createNote(
  input: CreateNoteInput,
  "Deprecated (use 'input' field instead)."
  data: CreateNoteDataInput
) : NoteMutationOutput

  # Mutation for updating a Note document
  updateNote(
  input: UpdateNoteInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateNoteDataInput 
) : NoteMutationOutput

  # Mutation for upserting a Note document
  upsertNote(
  input: UpsertNoteInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateNoteDataInput
) : NoteMutationOutput

  # Mutation for deleting a Note document
  deleteNote(
  input: DeleteNoteInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteSelectorUniqueInput
) : NoteMutationOutput

  # Mutation for creating new NoteItem documents
  createNoteItem(
  input: CreateNoteItemInput,
  "Deprecated (use 'input' field instead)."
  data: CreateNoteItemDataInput
) : NoteItemMutationOutput

  # Mutation for updating a NoteItem document
  updateNoteItem(
  input: UpdateNoteItemInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteItemSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateNoteItemDataInput 
) : NoteItemMutationOutput

  # Mutation for upserting a NoteItem document
  upsertNoteItem(
  input: UpsertNoteItemInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteItemSelectorUniqueInput,
  "Deprecated (use 'input' field instead)."
  data: UpdateNoteItemDataInput
) : NoteItemMutationOutput

  # Mutation for deleting a NoteItem document
  deleteNoteItem(
  input: DeleteNoteItemInput,
  "Deprecated (use 'input' field instead)."
  selector: NoteItemSelectorUniqueInput
) : NoteItemMutationOutput

}


