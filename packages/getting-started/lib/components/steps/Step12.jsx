import React from 'react';
import { Components, registerComponent } from 'meteor/vulcan:core';

// Relations

const text = [`
Let's keep learning how to harness the power of GraphQL. One of GraphQL's coolest features is that you're not limited to the fields that are in your database. In fact, GraphQL couldn't care less about your database: it only follows what *you* specify. 

This means that even though our database and JavaScript schema contain a \`userId\` field of type \`String\`, we can make our GraphQL schema contain a \`user\` field of type \`User\` instead!

In Vulcan, this is done automatically through field resolvers, and more specifically field [relations](http://docs.vulcanjs.org/relations.html).

Find the \`userId\` field in your \'lib/modules/schema.js\' file and add the following property to it:
`,`
~~~js
resolveAs: {
  fieldName: 'user',
  type: 'User',
},
~~~
`,`
We're specifying two things here:

1. First, our new “virtual” field will be named \`user\` instead of \`userId\`. Having different names is important to avoid confusion when it comes time to querying our API, since \`userId\` is a string but \`user\` will be a complex object. 
2. Then, we specify that this new \`user\` field should be of type \`User\`. That type already exists because it was auto-generated by the \`Users\` collection.

One more thing: we need to ask for that \`user\` field in our \`MovieFragment\` fragment. Go to \`lib/modules/fragments.js\` and modify the fragment like so:
`,`
~~~js
fragment MovieFragment on Movie {
  _id
  createdAt
  name
  user{
    displayName
  }
}
~~~
`];

const after = `
If you're seeing every user's \`displayName\` next to their review, this means our custom field resolver worked! 

And as you can see, the *graph* part of *GraphQL* means we can traverse our API graph using nested structures and leveraging each type's existing resolvers, without needing to actually store each user's \`displayName\` inside our \`Movies\` documents. 

Also, while we've used Vulcan's automatic \`hasOne\` relation here, you can also have \`hasMany\` relations by storing an array of IDs instead of a single one. And you can also have completely arbitrary field resolvers that return any data you want or even hit a third-party API!
`;

const Step12 = () => (
  <Components.Step step={12} text={text} after={after} />
);

registerComponent({ name: 'Step12', component: Step12 });